package store

import (
	//	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"

	"golang.org/x/crypto/pbkdf2"
)

const SealKeyBytes = 16
const KeyBytes = DictKeyBytes + SealKeyBytes

// GenerateKey generates a fresh, random key and returns it.
func GenerateKey() []byte {
	K := make([]byte, KeyBytes)
	_, err := rand.Read(K)
	if err != nil {
		return nil
	}
	return K
}

// DeriveKeyFromPassword derives a key from a password and (optional) salt and
// returns it.
//
// If salt == nil, then no salt is used. Note that the salt is not the same as
// pb.DictParams.Salt. pb.DictParams.Salt is generated by NewDict(), which in turn
// depends on the key.
func DeriveKeyFromPassword(password, salt []byte) []byte {
	return pbkdf2.Key(password, salt, 4096, KeyBytes, sha256.New)
}

type PubStore struct {
	dict   *PubDict
	sealed [][]byte
	graph  Graph
}

type PrivStore struct {
	dict *PrivDict
	aead cipher.AEAD
}

func NewStore(K []byte, M map[string]string) (*PubStore, *PrivStore, error) {

	cM := newCMap(M)
	defer cM.free()

	pub := new(PubStore)
	priv := new(PrivStore)

	var err error
	pub.dict, priv.dict, pub.graph, err = newDictAndGraph(K[DictKeyBytes:], cM)
	if err != nil {
		return nil, nil, err
	}

	return pub, priv, nil
}

func (pub *PubStore) Free() {
	pub.dict.Free()
}

func (priv *PrivStore) Free() {
	priv.dict.Free()
}
