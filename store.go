// Copyright (c) 2017, Christopher Patton.
// All rights reserved.
package store

// TODO(me) Missing features:
//  * PubStore) <--> protobuf

/*
// The next line gets things going on Mac:
#cgo CPPFLAGS: -I/usr/local/opt/openssl/include
#cgo LDFLAGS: -lstruct -lcrypto
#include <struct/const.h>
#include <struct/dict.h>
#include "string.h"

char **new_str_list(int len) {
	return calloc(sizeof(char *), len);
}

int *new_int_list(int len) {
	return calloc(sizeof(int), len);
}

void set_str_list(char **list, int idx, char *val) {
	list[idx] = val;
}

void set_int_list(int *list, int idx, int val) {
	list[idx] = val;
}

int get_int_list(int *list, int idx) {
	return list[idx];
}

void free_str_list(char **list, int len) {
	int i;
	for (i = 0; i < len; i++) {
		if (list[i] != NULL) {
			free(list[i]);
		}
	}
	free(list);
}

void free_int_list(int *list) {
	free(list);
}

char *get_row_ptr(char *table, int row, int row_bytes) {
	return &table[row * row_bytes];
}
*/
import "C"
import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"unsafe"

	"github.com/golang/protobuf/proto"
	"golang.org/x/crypto/pbkdf2"
)

// Number of bytes to use for the salt. The salt is a random string used to
// construct the table. It is prepended to the input of each HMAC call.
const SaltBytes = 8

// Number of row bytes allocated for the tag.
const TagBytes = 3

// The maximum length of the row. In general, the length of the row depends on
// the length of the longest output in the map. HASH_BYTES is defined in
// c/const.h.
const MaxRowBytes = C.HASH_BYTES

// The maximum length of the outputs. 1 byte of each row is allocated for
// padding the output string.
const MaxOutputBytes = MaxRowBytes - TagBytes - 1

// Length of the HMAC key. HMAC_KEY_BYTES is defined in c/const.h.
const KeyBytes = C.HMAC_KEY_BYTES

type Error string

func (err Error) Error() string {
	return string(err)
}

// Returned by Get() and priv.GetValue() if the input was not found in the
// dictionary.
const ItemNotFound = Error("item not found")

// Returned by GetRow() in case idx not in the table index.
const ErrorIdx = Error("index out of range")

// CError propagates an error from the internal C code.
func CError(fn string, errNo C.int) Error {
	return Error(fmt.Sprintf("%s returns error %d", fn, errNo))
}

// Returned by New(), Get(), priv.GetIdx(), or priv.GetValue() if the C
// implementation of HMAC returns an error.
const ErrorHMAC = Error("HMAC failed")

// The public representation of the map.
type PubStore struct {
	dict *C.cdict_t
}

// The private state required for evaluation queries.
type PrivStore struct {
	tinyCtx *C.tiny_ctx
	params  C.dict_params_t
}

// GenerateKey generates a fresh, random key and returns it.
func GenerateKey() []byte {
	K := make([]byte, KeyBytes)
	_, err := rand.Read(K)
	if err != nil {
		return nil
	}
	return K
}

// DeriveKeyFromPassword derives a key from a password and (optional) salt and
// returns it.
//
// NOTE The salt is not the same as StoreParams.Salt. StoreParams.Salt is
// generated by New(), which in turn depends on the key.
func DeriveKeyFromPassword(password, salt []byte) []byte {
	return pbkdf2.Key(password, salt, 4096, KeyBytes, sha256.New)
}

// New generates a new structure (pub, priv) for the map M and key K.
//
// NOTE You must call pub.Free() and priv.Free() before these variables go out
// of scope. These structures contain C types that were allocated on the heap
// and must be freed before losing a reference to them.
func New(K []byte, M map[string]string) (*PubStore, *PrivStore, error) {

	pub := new(PubStore)

	// Copy input/output pairs into C land.
	itemCt := C.int(len(M))
	inputs := C.new_str_list(itemCt)
	inputBytes := C.new_int_list(itemCt)
	outputs := C.new_str_list(itemCt)
	outputBytes := C.new_int_list(itemCt)
	defer C.free_str_list(inputs, itemCt)
	defer C.free_str_list(outputs, itemCt)
	defer C.free_int_list(inputBytes)
	defer C.free_int_list(outputBytes)

	maxOutputueBytes := 0
	i := C.int(0)
	for input, output := range M {
		if len(output) > maxOutputueBytes {
			maxOutputueBytes = len(output)
		}
		// NOTE C.CString() copies all the bytes of its input, even if it
		// encounters a null byte.
		C.set_str_list(inputs, i, C.CString(input))
		C.set_int_list(inputBytes, i, C.int(len(input)))
		C.set_str_list(outputs, i, C.CString(output))
		C.set_int_list(outputBytes, i, C.int(len(output)))
		i++
	}

	// Allocate a new dictionary object.
	tableLen := C.dict_compute_table_length(C.int(len(M)))
	dict := C.dict_new(
		tableLen,
		C.int(maxOutputueBytes),
		C.int(TagBytes),
		C.int(SaltBytes))
	if dict == nil {
		return nil, nil, Error(fmt.Sprintf("maxOutputBytes > %d", MaxOutputBytes))
	}
	defer C.dict_free(dict)

	params := cParamsToStoreParams(&dict.params)

	// Create priv.
	//
	// NOTE dict.salt is not set, and so priv.params.salt is not set. It's
	// necessary to set it after calling C.dict_create().
	priv, err := NewPrivStore(K, params)
	if err != nil {
		return nil, nil, err
	}

	// Create the dictionary.
	errNo := C.dict_create(
		dict, priv.tinyCtx, inputs, inputBytes, outputs, outputBytes, itemCt)
	if errNo != C.OK {
		priv.Free()
		return nil, nil, CError("dict_create", errNo)
	}

	// Copy salt to priv.params.
	C.memcpy(unsafe.Pointer(priv.params.salt),
		unsafe.Pointer(dict.params.salt),
		C.size_t(priv.params.salt_bytes))

	// Create compressed representation (no 0 rows).
	pub.dict = C.dict_compress(dict)

	return pub, priv, nil
}

// Get queries input on the structure (pub, priv). The result is M[input] =
// output, where M is the map represented by (pub, priv).
func Get(pub *PubStore, priv *PrivStore, input string) (string, error) {
	cInput := C.CString(input)
	// NOTE(me) Better way to do the following?
	cOutput := C.CString(string(make([]byte, pub.dict.params.max_value_bytes)))
	cOutputBytes := C.int(0)
	defer C.free(unsafe.Pointer(cInput))
	defer C.free(unsafe.Pointer(cOutput))
	errNo := C.cdict_get(
		pub.dict, priv.tinyCtx, cInput, C.int(len(input)), cOutput, &cOutputBytes)
	if errNo == C.ERR_DICT_BAD_KEY {
		return "", ItemNotFound
	} else if errNo != C.OK {
		return "", CError("cdict_get", errNo)
	}
	return C.GoStringN(cOutput, cOutputBytes), nil
}

// GetRow returns the row of the table associated with idx.
func (pub *PubStore) GetRow(idx int) ([]byte, error) {
	if idx < 0 || idx >= int(pub.dict.params.table_length) {
		return nil, ErrorIdx
	}
	realIdx := C.cdict_binsearch(pub.dict, C.int(idx), 0,
		pub.dict.compressed_table_length)
	return pub.getRealRow(realIdx), nil
}

// GetTable copies the table to a new []byte and returns it.
func (pub *PubStore) GetTable() []byte {
	rowBytes := int(pub.dict.params.row_bytes)
	tableLen := int(pub.dict.compressed_table_length)
	table := make([]byte, rowBytes*tableLen)
	for i := 0; i < tableLen; i++ {
		copy(table[i*rowBytes:(i+1)*rowBytes], pub.getRealRow(C.int(i)))
	}
	return table
}

// GetTableIdx copies the table index to a new []int and returns it.
func (pub *PubStore) GetTableIdx() []int {
	tableIdx := make([]int, pub.dict.compressed_table_length)
	for i := 0; i < int(pub.dict.compressed_table_length); i++ {
		tableIdx[i] = int(C.get_int_list(pub.dict.idx, C.int(i)))
	}
	return tableIdx
}

// ToString returns a string representation of the table.
func (pub *PubStore) ToString() string {
	rowBytes := int(pub.dict.params.row_bytes)
	tableLen := int(pub.dict.compressed_table_length)
	table := pub.GetTable()
	idx := pub.GetTableIdx()
	str := ""
	for i := 0; i < tableLen; i++ {
		row := table[i*rowBytes : (i+1)*rowBytes]
		str += fmt.Sprintf("%-3d %s\n", idx[i], hex.EncodeToString(row))
	}
	return str
}

// GetParams returns the public parameters of the data structure.
func (pub *PubStore) GetParams() *StoreParams {
	return cParamsToStoreParams(&pub.dict.params)
}

// Free deallocates memory associated with the underlying C implementation of
// the data structure.
func (pub *PubStore) Free() {
	C.cdict_free(pub.dict)
}

// NewPrivStore creates a new *PrivStore from a key and parameters.
//
// NOTE You must destroy this with priv.Free().
// NOTE Called by New().
func NewPrivStore(K []byte, params *StoreParams) (*PrivStore, error) {

	priv := new(PrivStore)

	// Check that K is the right length.
	if len(K) != KeyBytes {
		return nil, Error(fmt.Sprintf("len(K) = %d, expected %d", len(K), KeyBytes))
	}

	priv.tinyCtx = C.tinyprf_new(C.int(params.GetTableLen()))
	if priv.tinyCtx == nil {
		return nil, Error("tableLen < 2")
	}
	priv.params.salt = (*C.char)(C.malloc(C.size_t(len(params.Salt) + 1)))

	cK := C.CString(string(K))
	defer C.free(unsafe.Pointer(cK))
	errNo := C.tinyprf_init(priv.tinyCtx, cK)
	if errNo != C.OK {
		priv.Free()
		return nil, CError("tinyprf_init", errNo)
	}

	setCParamsFromStoreParams(&priv.params, params)
	return priv, nil
}

// GetIdx computes the two indices of the table associated with input and
// returns them.
func (priv *PrivStore) GetIdx(input string) (int, int, error) {
	cInput := C.CString(input)
	defer C.free(unsafe.Pointer(cInput))
	var x, y C.int
	errNo := C.dict_compute_rows(
		priv.params, priv.tinyCtx, cInput, C.int(len(input)), &x, &y)
	if errNo != C.OK {
		return 0, 0, CError("dict_compute_rows", errNo)
	}
	return int(x), int(y), nil
}

// GetValue computes the output associated with the input and the table rows.
func (priv *PrivStore) GetValue(input string, rows [][]byte) (string, error) {
	cInput := C.CString(input)
	// NOTE(me) Better way to do the following?
	cOutput := C.CString(string(make([]byte, priv.params.max_value_bytes)))
	defer C.free(unsafe.Pointer(cInput))
	defer C.free(unsafe.Pointer(cOutput))
	cOutputBytes := C.int(0)

	xRow := C.CString(string(rows[0]))
	yRow := C.CString(string(rows[1]))
	defer C.free(unsafe.Pointer(xRow))
	defer C.free(unsafe.Pointer(yRow))

	errNo := C.dict_compute_value(priv.params, priv.tinyCtx, cInput,
		C.int(len(input)), xRow, yRow, cOutput, &cOutputBytes)

	if errNo == C.ERR_DICT_BAD_KEY {
		return "", ItemNotFound
	} else if errNo != C.OK {
		return "", CError("dict_compute_value", errNo)
	}
	return C.GoStringN(cOutput, cOutputBytes), nil
}

// GetParams returns the public parameters of the data structure.
func (priv *PrivStore) GetParams() *StoreParams {
	return cParamsToStoreParams(&priv.params)
}

// Free deallocates moemory associated with the C implementation of the
// underlying data structure.
func (priv *PrivStore) Free() {
	C.free(unsafe.Pointer(priv.params.salt))
	C.tinyprf_free(priv.tinyCtx)
}

// Returns true if the first saltBytes of *a and *b are equal.
func cBytesToString(str *C.char, bytes C.int) string {
	return C.GoStringN(str, bytes)
}

// cParamsToStoreParams creates *StoreParams from a *C.dict_params_t, making a
// deep copy of the salt.
//
// Called by pub.GetParams() and priv.GetParams().
func cParamsToStoreParams(cParams *C.dict_params_t) *StoreParams {
	params := &StoreParams{
		TableLen:       proto.Int32(int32(cParams.table_length)),
		MaxOutputBytes: proto.Int32(int32(cParams.max_value_bytes)),
		RowBytes:       proto.Int32(int32(cParams.row_bytes)),
		TagBytes:       proto.Int32(int32(cParams.tag_bytes)),
		Salt:           C.GoBytes(unsafe.Pointer(cParams.salt), cParams.salt_bytes),
	}
	return params
}

// setCParamsFromStoreparams copies parameters to a *C.dict_params_t.
//
// Must call C.free(cParams.salt)
func setCParamsFromStoreParams(cParams *C.dict_params_t, params *StoreParams) {
	cParams.table_length = C.int(params.GetTableLen())
	cParams.max_value_bytes = C.int(params.GetMaxOutputBytes())
	cParams.row_bytes = C.int(params.GetRowBytes())
	cParams.tag_bytes = C.int(params.GetTagBytes())
	cParams.salt_bytes = C.int(len(params.Salt))
	cBuf := C.CString(string(params.Salt))
	C.memcpy(unsafe.Pointer(cParams.salt),
		unsafe.Pointer(cBuf),
		C.size_t(cParams.salt_bytes))
}

// getRealRow copies a row of the table and returns it.
func (pub *PubStore) getRealRow(idx C.int) []byte {
	rowPtr := C.get_row_ptr(pub.dict.table, idx, pub.dict.params.row_bytes)
	return C.GoBytes(unsafe.Pointer(rowPtr), pub.dict.params.row_bytes)
}
